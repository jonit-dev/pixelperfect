import { GoogleGenAI } from '@google/genai';
import { NextRequest, NextResponse } from 'next/server';
import { serverEnv } from '@/config/env';

interface IUpscaleConfig {
  mode: 'upscale' | 'enhance' | 'both' | 'custom';
  scale: 2 | 4;
  denoise: boolean;
  enhanceFace: boolean;
  preserveText: boolean;
  customPrompt?: string;
}

export const runtime = 'edge';

const generatePrompt = (config: IUpscaleConfig): string => {
  // Use custom prompt if in custom mode and a prompt is provided
  if (config.mode === 'custom' && config.customPrompt && config.customPrompt.trim().length > 0) {
    return config.customPrompt;
  }

  // Fallback to 'both' logic if in custom mode but empty prompt, or normal mode logic
  const effectiveMode = config.mode === 'custom' ? 'both' : config.mode;

  // Refined Prompt to avoid IMAGE_RECITATION
  // We frame this as a "Generation" and "Reconstruction" task rather than just "Restoration"
  let prompt =
    'Task: Generate a high-definition version of the provided image with significantly improved quality. ';

  // Mode Selection Logic
  switch (effectiveMode) {
    case 'upscale':
      prompt += `Action: Reconstruct the image at ${config.scale}x resolution (target 2K/4K). Aggressively sharpen edges and hallucinate plausible fine details to remove blur. `;
      break;
    case 'enhance':
      prompt +=
        'Action: Refine the image clarity. Remove all JPEG compression artifacts, grain, and sensor noise. Balance the lighting and color saturation for a professional look. ';
      break;
    case 'both':
    default:
      prompt += `Action: Reconstruct the image at ${config.scale}x resolution. Simultaneously remove noise/artifacts and sharpen fine details. The output must be crisp and photorealistic. `;
      break;
  }

  // Feature Constraints
  if (config.preserveText) {
    prompt +=
      'Constraint: Text and logos MUST remain legible, straight, and spelled correctly. Sharpen the text boundaries. ';
  } else {
    prompt += 'Constraint: Prioritize visual aesthetics. ';
  }

  if (config.enhanceFace) {
    prompt +=
      "Constraint: Enhance facial features naturally (eyes, skin texture) without altering the person's identity. ";
  }

  if (config.denoise) {
    prompt += 'Constraint: Apply strong denoising to smooth out flat areas. ';
  }

  prompt += 'Output: Return ONLY the generated image.';

  return prompt;
};

export async function POST(req: NextRequest) {
  try {
    const apiKey = serverEnv.GEMINI_API_KEY;
    if (!apiKey) {
      return NextResponse.json(
        { error: 'Server configuration error: GEMINI_API_KEY is missing.' },
        { status: 500 }
      );
    }

    const body = await req.json();
    const { imageData, mimeType, config } = body;

    if (!imageData || !config) {
      return NextResponse.json({ error: 'Missing imageData or configuration.' }, { status: 400 });
    }

    const prompt = generatePrompt(config);
    const genAI = new GoogleGenAI({ apiKey });

    // Call Gemini Nano Banana (gemini-2.5-flash-image)
    const response = await genAI.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: [
        {
          parts: [
            {
              inlineData: {
                mimeType: mimeType || 'image/jpeg',
                data: imageData,
              },
            },
            { text: prompt },
          ],
        },
      ],
      config: {
        // A lower temperature can sometimes help with fidelity, but for upscaling we might want a bit of creativity to avoid recitation
        temperature: 0.4,
      },
    });

    // Extract the image from the response
    const parts = response.candidates?.[0]?.content?.parts;
    const finishReason = response.candidates?.[0]?.finishReason;

    if (finishReason && finishReason !== 'STOP') {
      let errorMsg = `Model stopped generation. Reason: ${finishReason}`;

      if (finishReason === 'RECITATION') {
        errorMsg =
          "The model detected that the output would be too similar to the input (Recitation). Try using the 'Enhance' mode or changing the upscale factor.";
      } else if (finishReason === 'SAFETY') {
        errorMsg = "The image triggered the model's safety filters.";
      }

      return NextResponse.json({ error: errorMsg }, { status: 422 });
    }

    if (!parts || parts.length === 0) {
      return NextResponse.json({ error: 'No content generated by the model.' }, { status: 500 });
    }

    for (const part of parts) {
      if (part.inlineData && part.inlineData.data) {
        const base64Image = part.inlineData.data;
        const responseMimeType = part.inlineData.mimeType || 'image/png';
        return NextResponse.json({
          imageData: `data:${responseMimeType};base64,${base64Image}`,
        });
      }
    }

    const textPart = parts.find(p => p.text);
    if (textPart) {
      return NextResponse.json(
        {
          error:
            'The model returned text instead of an image. It may have refused the specific request.',
          details: textPart.text,
        },
        { status: 422 }
      );
    }

    return NextResponse.json({ error: 'No image data found in the response.' }, { status: 500 });
  } catch (error: any) {
    console.error('AI Processing Error:', error);
    return NextResponse.json(
      { error: error.message || 'An unexpected error occurred.' },
      { status: 500 }
    );
  }
}
