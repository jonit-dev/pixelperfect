-- ============================================================================
-- PixelPerfect Supabase Complete Setup
-- ============================================================================
-- Generated by setup-supabase.sh
--
-- Instructions:
-- 1. Open Supabase Dashboard > SQL Editor
-- 2. Copy and paste this entire file
-- 3. Click "Run" to execute
--
-- This script is idempotent - safe to run multiple times
-- ============================================================================


-- ========================================
-- Migration: 20250120_create_profiles_table.sql
-- ========================================

-- Create profiles table to extend auth.users with Stripe data
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL PRIMARY KEY,
  stripe_customer_id TEXT UNIQUE,
  credits_balance INTEGER DEFAULT 10 NOT NULL,
  subscription_status TEXT CHECK (subscription_status IN ('active', 'trialing', 'past_due', 'canceled', 'unpaid')),
  subscription_tier TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Create index on stripe_customer_id for fast lookups
CREATE INDEX IF NOT EXISTS idx_profiles_stripe_customer_id ON public.profiles(stripe_customer_id);

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- RLS Policies
-- Users can view their own profile
CREATE POLICY "Users can view own profile"
  ON public.profiles
  FOR SELECT
  USING (auth.uid() = id);

-- Users can update their own profile (except credits_balance which is managed via RPC)
CREATE POLICY "Users can update own profile"
  ON public.profiles
  FOR UPDATE
  USING (auth.uid() = id)
  WITH CHECK (auth.uid() = id);

-- Service role can do everything (for webhooks)
CREATE POLICY "Service role has full access"
  ON public.profiles
  FOR ALL
  USING (auth.role() = 'service_role');

-- Create trigger to auto-create profile on user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, credits_balance)
  VALUES (NEW.id, 10);  -- Give new users 10 free credits
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to run the function on new user creation
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS on_profiles_updated ON public.profiles;
CREATE TRIGGER on_profiles_updated
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();


-- ========================================
-- Migration: 20250120_create_subscriptions_table.sql
-- ========================================

-- Create subscriptions table to mirror Stripe subscriptions
CREATE TABLE IF NOT EXISTS public.subscriptions (
  id TEXT PRIMARY KEY, -- Stripe subscription ID
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  status TEXT NOT NULL,
  price_id TEXT NOT NULL,
  current_period_start TIMESTAMPTZ NOT NULL,
  current_period_end TIMESTAMPTZ NOT NULL,
  cancel_at_period_end BOOLEAN DEFAULT FALSE NOT NULL,
  canceled_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Create indexes for efficient queries
CREATE INDEX IF NOT EXISTS idx_subscriptions_user_id ON public.subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON public.subscriptions(status);
CREATE INDEX IF NOT EXISTS idx_subscriptions_current_period_end ON public.subscriptions(current_period_end);

-- Enable RLS
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;

-- RLS Policies
-- Users can view their own subscriptions
CREATE POLICY "Users can view own subscriptions"
  ON public.subscriptions
  FOR SELECT
  USING (auth.uid() = user_id);

-- Service role can do everything (for webhooks)
CREATE POLICY "Service role has full access to subscriptions"
  ON public.subscriptions
  FOR ALL
  USING (auth.role() = 'service_role');

-- Create updated_at trigger
DROP TRIGGER IF EXISTS on_subscriptions_updated ON public.subscriptions;
CREATE TRIGGER on_subscriptions_updated
  BEFORE UPDATE ON public.subscriptions
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();

-- Optional: Create products table to sync Stripe product catalog
CREATE TABLE IF NOT EXISTS public.products (
  id TEXT PRIMARY KEY, -- Stripe product ID
  name TEXT NOT NULL,
  description TEXT,
  active BOOLEAN DEFAULT TRUE NOT NULL,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Enable RLS for products (public read access)
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Products are publicly readable"
  ON public.products
  FOR SELECT
  USING (true);

CREATE POLICY "Service role can manage products"
  ON public.products
  FOR ALL
  USING (auth.role() = 'service_role');

-- Create prices table to sync Stripe prices
CREATE TABLE IF NOT EXISTS public.prices (
  id TEXT PRIMARY KEY, -- Stripe price ID
  product_id TEXT REFERENCES public.products(id) ON DELETE CASCADE NOT NULL,
  active BOOLEAN DEFAULT TRUE NOT NULL,
  currency TEXT NOT NULL,
  unit_amount INTEGER, -- Amount in cents
  type TEXT CHECK (type IN ('one_time', 'recurring')) NOT NULL,
  interval TEXT CHECK (interval IN ('day', 'week', 'month', 'year')),
  interval_count INTEGER,
  trial_period_days INTEGER,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_prices_product_id ON public.prices(product_id);
CREATE INDEX IF NOT EXISTS idx_prices_active ON public.prices(active);

-- Enable RLS for prices (public read access)
ALTER TABLE public.prices ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Prices are publicly readable"
  ON public.prices
  FOR SELECT
  USING (true);

CREATE POLICY "Service role can manage prices"
  ON public.prices
  FOR ALL
  USING (auth.role() = 'service_role');

-- Create updated_at triggers
DROP TRIGGER IF EXISTS on_products_updated ON public.products;
CREATE TRIGGER on_products_updated
  BEFORE UPDATE ON public.products
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();

DROP TRIGGER IF EXISTS on_prices_updated ON public.prices;
CREATE TRIGGER on_prices_updated
  BEFORE UPDATE ON public.prices
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();


-- ========================================
-- Migration: 20250121_create_credit_transactions_table.sql
-- ========================================

-- Credit transactions audit log table
-- Records all credit changes for audit trail and debugging

CREATE TABLE IF NOT EXISTS public.credit_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  amount INTEGER NOT NULL, -- Positive for additions, negative for deductions
  type TEXT NOT NULL CHECK (type IN ('purchase', 'subscription', 'usage', 'refund', 'bonus')),
  reference_id TEXT, -- Stripe session ID, job ID, etc.
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for efficient queries
CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON public.credit_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_type ON public.credit_transactions(type);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_created_at ON public.credit_transactions(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_reference_id ON public.credit_transactions(reference_id);

-- Enable RLS
ALTER TABLE public.credit_transactions ENABLE ROW LEVEL SECURITY;

-- RLS Policies
-- Users can view their own transaction history
CREATE POLICY "Users can view own transactions"
  ON public.credit_transactions
  FOR SELECT
  USING (auth.uid() = user_id);

-- Service role can do everything (for webhooks and RPCs)
CREATE POLICY "Service role has full access to transactions"
  ON public.credit_transactions
  FOR ALL
  USING (auth.role() = 'service_role');


-- ========================================
-- Migration: 20250121_create_processing_jobs_table.sql
-- ========================================

-- Processing jobs table for tracking image processing requests
-- Links to credit usage and provides job history

CREATE TABLE IF NOT EXISTS public.processing_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'queued' CHECK (status IN ('queued', 'processing', 'completed', 'failed')),
  input_image_path TEXT NOT NULL,
  output_image_path TEXT,
  credits_used INTEGER NOT NULL DEFAULT 1,
  processing_mode TEXT NOT NULL DEFAULT 'standard' CHECK (processing_mode IN ('standard', 'enhanced', 'gentle', 'portrait', 'product')),
  settings JSONB DEFAULT '{}',
  error_message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for efficient queries
CREATE INDEX IF NOT EXISTS idx_processing_jobs_user_id ON public.processing_jobs(user_id);
CREATE INDEX IF NOT EXISTS idx_processing_jobs_status ON public.processing_jobs(status);
CREATE INDEX IF NOT EXISTS idx_processing_jobs_created_at ON public.processing_jobs(created_at DESC);

-- Enable RLS
ALTER TABLE public.processing_jobs ENABLE ROW LEVEL SECURITY;

-- RLS Policies
-- Users can view their own jobs
CREATE POLICY "Users can view own jobs"
  ON public.processing_jobs
  FOR SELECT
  USING (auth.uid() = user_id);

-- Users can create their own jobs
CREATE POLICY "Users can create own jobs"
  ON public.processing_jobs
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Service role can do everything (for background processing)
CREATE POLICY "Service role has full access to jobs"
  ON public.processing_jobs
  FOR ALL
  USING (auth.role() = 'service_role');

-- Updated at trigger
DROP TRIGGER IF EXISTS on_processing_jobs_updated ON public.processing_jobs;
CREATE TRIGGER on_processing_jobs_updated
  BEFORE UPDATE ON public.processing_jobs
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();


-- ========================================
-- Migration: 20250120_create_rpc_functions.sql
-- ========================================

-- Create secure RPC function to increment user credits
-- This function uses SECURITY DEFINER to bypass RLS, ensuring only this function can modify credits
CREATE OR REPLACE FUNCTION public.increment_credits(target_user_id UUID, amount INTEGER)
RETURNS void
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  UPDATE public.profiles
  SET credits_balance = credits_balance + amount
  WHERE id = target_user_id;
$$;

-- Grant execute permission to authenticated users (though only service role should call it via webhooks)
GRANT EXECUTE ON FUNCTION public.increment_credits(UUID, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.increment_credits(UUID, INTEGER) TO service_role;

-- Create RPC function to decrement user credits (for usage tracking)
-- Returns the new balance, or NULL if insufficient credits
CREATE OR REPLACE FUNCTION public.decrement_credits(target_user_id UUID, amount INTEGER)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  current_balance INTEGER;
  new_balance INTEGER;
BEGIN
  -- Get current balance
  SELECT credits_balance INTO current_balance
  FROM public.profiles
  WHERE id = target_user_id;

  -- Check if user exists and has sufficient credits
  IF current_balance IS NULL THEN
    RAISE EXCEPTION 'User profile not found';
  END IF;

  IF current_balance < amount THEN
    RAISE EXCEPTION 'Insufficient credits';
  END IF;

  -- Decrement credits
  UPDATE public.profiles
  SET credits_balance = credits_balance - amount
  WHERE id = target_user_id
  RETURNING credits_balance INTO new_balance;

  RETURN new_balance;
END;
$$;

GRANT EXECUTE ON FUNCTION public.decrement_credits(UUID, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.decrement_credits(UUID, INTEGER) TO service_role;

-- Create function to get user's current subscription status
CREATE OR REPLACE FUNCTION public.get_active_subscription(target_user_id UUID)
RETURNS TABLE (
  subscription_id TEXT,
  status TEXT,
  price_id TEXT,
  current_period_end TIMESTAMPTZ,
  cancel_at_period_end BOOLEAN
)
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT id, status, price_id, current_period_end, cancel_at_period_end
  FROM public.subscriptions
  WHERE user_id = target_user_id
    AND status IN ('active', 'trialing')
  ORDER BY created_at DESC
  LIMIT 1;
$$;

GRANT EXECUTE ON FUNCTION public.get_active_subscription(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_active_subscription(UUID) TO service_role;

-- Create function to check if user has sufficient credits
CREATE OR REPLACE FUNCTION public.has_sufficient_credits(target_user_id UUID, required_amount INTEGER)
RETURNS BOOLEAN
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT credits_balance >= required_amount
  FROM public.profiles
  WHERE id = target_user_id;
$$;

GRANT EXECUTE ON FUNCTION public.has_sufficient_credits(UUID, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.has_sufficient_credits(UUID, INTEGER) TO service_role;


-- ========================================
-- Migration: 20250121_enhanced_credit_functions.sql
-- ========================================

-- Enhanced credit functions with transaction logging
-- These functions provide atomic credit operations with full audit trail

-- Increment credits with transaction logging
CREATE OR REPLACE FUNCTION public.increment_credits_with_log(
  target_user_id UUID,
  amount INTEGER,
  transaction_type TEXT DEFAULT 'purchase',
  ref_id TEXT DEFAULT NULL,
  description TEXT DEFAULT NULL
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  new_balance INTEGER;
BEGIN
  -- Increment credits
  UPDATE public.profiles
  SET credits_balance = credits_balance + amount
  WHERE id = target_user_id
  RETURNING credits_balance INTO new_balance;

  IF new_balance IS NULL THEN
    RAISE EXCEPTION 'User not found: %', target_user_id;
  END IF;

  -- Log transaction
  INSERT INTO public.credit_transactions (user_id, amount, type, reference_id, description)
  VALUES (target_user_id, amount, transaction_type, ref_id, description);

  RETURN new_balance;
END;
$$;

GRANT EXECUTE ON FUNCTION public.increment_credits_with_log(UUID, INTEGER, TEXT, TEXT, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.increment_credits_with_log(UUID, INTEGER, TEXT, TEXT, TEXT) TO service_role;

-- Decrement credits with transaction logging (atomic with row lock)
CREATE OR REPLACE FUNCTION public.decrement_credits_with_log(
  target_user_id UUID,
  amount INTEGER,
  transaction_type TEXT DEFAULT 'usage',
  ref_id TEXT DEFAULT NULL,
  description TEXT DEFAULT NULL
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  current_balance INTEGER;
  new_balance INTEGER;
BEGIN
  -- Lock row and check balance
  SELECT credits_balance INTO current_balance
  FROM public.profiles
  WHERE id = target_user_id
  FOR UPDATE;

  IF current_balance IS NULL THEN
    RAISE EXCEPTION 'User not found: %', target_user_id;
  END IF;

  IF current_balance < amount THEN
    RAISE EXCEPTION 'Insufficient credits. Required: %, Available: %', amount, current_balance;
  END IF;

  -- Decrement credits
  UPDATE public.profiles
  SET credits_balance = credits_balance - amount
  WHERE id = target_user_id
  RETURNING credits_balance INTO new_balance;

  -- Log transaction (negative amount for deduction)
  INSERT INTO public.credit_transactions (user_id, amount, type, reference_id, description)
  VALUES (target_user_id, -amount, transaction_type, ref_id, description);

  RETURN new_balance;
END;
$$;

GRANT EXECUTE ON FUNCTION public.decrement_credits_with_log(UUID, INTEGER, TEXT, TEXT, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.decrement_credits_with_log(UUID, INTEGER, TEXT, TEXT, TEXT) TO service_role;

-- Refund credits (convenience wrapper for failed processing)
CREATE OR REPLACE FUNCTION public.refund_credits(
  target_user_id UUID,
  amount INTEGER,
  job_id TEXT DEFAULT NULL
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN public.increment_credits_with_log(
    target_user_id,
    amount,
    'refund',
    job_id,
    'Processing refund'
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.refund_credits(UUID, INTEGER, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.refund_credits(UUID, INTEGER, TEXT) TO service_role;


-- ========================================
-- Migration: 20250121_fix_initial_credits.sql
-- ========================================

-- Fix initial credits and add welcome bonus logging
-- This migration:
-- 1. Updates the handle_new_user trigger to log welcome bonus
-- 2. Backfills existing users with 0 credits to 10

-- Update handle_new_user trigger to include welcome bonus logging
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  -- Create profile with 10 welcome credits
  INSERT INTO public.profiles (id, credits_balance, subscription_status, subscription_tier)
  VALUES (NEW.id, 10, 'free', 'free');

  -- Log the welcome bonus transaction
  INSERT INTO public.credit_transactions (user_id, amount, type, description)
  VALUES (NEW.id, 10, 'bonus', 'Welcome bonus credits');

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Recreate trigger (function already updated above)
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Backfill existing users with 0 credits
-- This gives them the welcome bonus they should have received
DO $$
DECLARE
  updated_count INTEGER;
  user_record RECORD;
BEGIN
  -- Update users with 0 credits
  UPDATE public.profiles
  SET credits_balance = 10
  WHERE credits_balance = 0;

  GET DIAGNOSTICS updated_count = ROW_COUNT;

  -- Log backfill transactions for users that were updated
  -- (We can't know exactly which users were backfilled after the fact,
  -- so we log for all users who now have exactly 10 credits and no transactions)
  FOR user_record IN
    SELECT p.id
    FROM public.profiles p
    LEFT JOIN public.credit_transactions ct ON ct.user_id = p.id
    WHERE ct.id IS NULL AND p.credits_balance = 10
  LOOP
    INSERT INTO public.credit_transactions (user_id, amount, type, description)
    VALUES (user_record.id, 10, 'bonus', 'Welcome bonus credits (backfill)');
  END LOOP;

  IF updated_count > 0 THEN
    RAISE NOTICE 'Backfilled % users with 10 credits', updated_count;
  END IF;
END;
$$;

