/**
 * Centralized Stripe Payment Configuration
 *
 * This file contains all Stripe pricing and product configuration.
 * Now derives from subscription.config.ts to ensure consistency.
 *
 * Legacy: Auto-generated by stripe-setup.sh on Fri Dec  5 17:19:50 PST 2025
 * Updated: Unified with subscription.config.ts as the single source of truth
 */

import { clientEnv, serverEnv } from './env';
import {
  getPriceIndex,
  resolvePriceId,
  resolvePlanOrPack,
  assertKnownPriceId,
  buildStripePrices,
  buildSubscriptionPlans,
  buildCreditPacks,
  buildHomepageTiers,
  getPlanByPriceId,
  buildSubscriptionPriceMap,
} from './subscription.utils';
import { getSubscriptionConfig } from './subscription.config';

/**
 * Stripe subscription plan metadata interface
 */
export interface ISubscriptionPlanMetadata {
  name: string;
  creditsPerMonth: number;
  maxRollover: number;
}

/**
 * Legacy subscription plan format
 * Used for backward compatibility with existing code
 */
interface ILegacySubscriptionPlan {
  key: string;
  name: string;
  creditsPerMonth: number;
  maxRollover: number;
  features: readonly string[];
  recommended: boolean;
  description?: string;
  price?: number;
  interval?: string;
}

// Stripe Price IDs - Derived from subscription.config.ts (single source of truth)
export const STRIPE_PRICES = buildStripePrices() as {
  // Subscription plans
  STARTER_MONTHLY: string;
  HOBBY_MONTHLY: string;
  PRO_MONTHLY: string;
  BUSINESS_MONTHLY: string;
  // Credit packs
  SMALL_CREDITS: string;
  MEDIUM_CREDITS: string;
  LARGE_CREDITS: string;
};

export type StripePriceKey = keyof typeof STRIPE_PRICES;

/**
 * Credit pack configuration with associated credits
 * Derived from subscription.config.ts
 */
export const CREDIT_PACKS = buildCreditPacks() as {
  SMALL_CREDITS: {
    name: string;
    description: string;
    price: number;
    credits: number;
    features: readonly string[];
    popular?: boolean;
  };
  MEDIUM_CREDITS: {
    name: string;
    description: string;
    price: number;
    credits: number;
    features: readonly string[];
    popular?: boolean;
  };
  LARGE_CREDITS: {
    name: string;
    description: string;
    price: number;
    credits: number;
    features: readonly string[];
    popular?: boolean;
  };
};

/**
 * Subscription plan configuration
 * Derived from subscription.config.ts
 */
export const SUBSCRIPTION_PLANS = buildSubscriptionPlans() as {
  STARTER_MONTHLY: {
    name: string;
    description: string;
    price: number;
    interval: 'month' | 'year';
    creditsPerMonth: number;
    maxRollover: number;
    key: string;
    features: readonly string[];
    recommended?: boolean;
  };
  HOBBY_MONTHLY: {
    name: string;
    description: string;
    price: number;
    interval: 'month' | 'year';
    creditsPerMonth: number;
    maxRollover: number;
    key: string;
    features: readonly string[];
    recommended?: boolean;
  };
  PRO_MONTHLY: {
    name: string;
    description: string;
    price: number;
    interval: 'month' | 'year';
    creditsPerMonth: number;
    maxRollover: number;
    key: string;
    features: readonly string[];
    recommended?: boolean;
  };
  BUSINESS_MONTHLY: {
    name: string;
    description: string;
    price: number;
    interval: 'month' | 'year';
    creditsPerMonth: number;
    maxRollover: number;
    key: string;
    features: readonly string[];
    recommended?: boolean;
  };
};

/**
 * Check if Stripe prices are configured
 */
export function isStripePricesConfigured(): boolean {
  return true; // Always return true for static configuration
}

/**
 * Get the price ID for a given key, with validation
 */
export function getPriceId(key: StripePriceKey): string {
  const priceId = STRIPE_PRICES[key];
  if (!priceId || priceId.includes('000000000000000000000')) {
    console.warn(`Stripe Price ID for ${key} is not properly configured.`);
  }
  return priceId;
}

/**
 * Homepage pricing tiers - derived from subscription plans
 * Used by Pricing.tsx on homepage
 * Now unified with subscription.config.ts
 */
export const HOMEPAGE_TIERS = buildHomepageTiers();

// =============================================================================
// Stripe Configuration Validation & Access
// =============================================================================

/**
 * Get the Stripe publishable key for client-side usage
 */
export function getStripePublishableKey(): string {
  return clientEnv.STRIPE_PUBLISHABLE_KEY;
}

/**
 * Get the Stripe secret key for server-side usage
 * Only accessible on the server
 */
export function getStripeSecretKey(): string {
  return serverEnv.STRIPE_SECRET_KEY || '';
}

/**
 * Get the Stripe webhook secret for server-side webhook verification
 */
export function getStripeWebhookSecret(): string {
  return serverEnv.STRIPE_WEBHOOK_SECRET || '';
}

/**
 * Complete Stripe configuration object
 * Use this to get all Stripe-related configuration in one place
 */
export function getStripeConfig(): {
  publishableKey: string;
  secretKey: string;
  webhookSecret: string;
  prices: typeof STRIPE_PRICES;
  creditPacks: typeof CREDIT_PACKS;
  subscriptionPlans: typeof SUBSCRIPTION_PLANS;
  homepageTiers: typeof HOMEPAGE_TIERS;
} {
  return {
    // Client-side configuration
    publishableKey: clientEnv.STRIPE_PUBLISHABLE_KEY,

    // Server-side configuration (only available on server)
    secretKey: serverEnv.STRIPE_SECRET_KEY || '',
    webhookSecret: serverEnv.STRIPE_WEBHOOK_SECRET || '',

    // Price IDs
    prices: STRIPE_PRICES,

    // Product configurations
    creditPacks: CREDIT_PACKS,
    subscriptionPlans: SUBSCRIPTION_PLANS,

    // Homepage pricing
    homepageTiers: HOMEPAGE_TIERS,
  };
}

/**
 * Validate that all required Stripe configuration is present
 * Returns an object with validation results
 */
export function validateStripeConfig(): {
  isValid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Check client-side configuration
  if (!clientEnv.STRIPE_PUBLISHABLE_KEY) {
    errors.push('NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY is not configured');
  } else if (
    clientEnv.STRIPE_PUBLISHABLE_KEY.includes('pk_test_xxx') ||
    clientEnv.STRIPE_PUBLISHABLE_KEY.includes('pk_live_xxx')
  ) {
    warnings.push('NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY appears to be a placeholder key');
  }

  // Check server-side configuration
  if (!serverEnv.STRIPE_SECRET_KEY) {
    errors.push('STRIPE_SECRET_KEY is not configured');
  } else if (
    serverEnv.STRIPE_SECRET_KEY.includes('dummy') ||
    serverEnv.STRIPE_SECRET_KEY.includes('placeholder')
  ) {
    warnings.push('STRIPE_SECRET_KEY appears to be a dummy/placeholder key');
  }

  if (!serverEnv.STRIPE_WEBHOOK_SECRET) {
    warnings.push(
      'STRIPE_WEBHOOK_SECRET is not configured - webhook signature verification will fail'
    );
  }

  // Check price IDs
  const missingPrices = Object.entries(STRIPE_PRICES)
    .filter(([, priceId]) => !priceId || priceId.includes('000000000000000000000'))
    .map(([key]) => key);

  if (missingPrices.length > 0) {
    errors.push(`Missing or invalid Stripe Price IDs: ${missingPrices.join(', ')}`);
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * Get subscription plan details for a given price ID
 * Now uses unified resolver from subscription.config.ts
 */
export function getPlanForPriceId(priceId: string): {
  key: string;
  name: string;
  creditsPerMonth: number;
  maxRollover: number;
  features: readonly string[];
  recommended: boolean;
  description?: string;
  price?: number;
  interval?: 'month' | 'year';
} | null {
  const resolved = resolvePriceId(priceId);

  // Only return plans, not credit packs
  if (!resolved || resolved.type !== 'plan') {
    return null;
  }

  // Get the actual plan from config
  const plan = getPlanByPriceId(priceId);
  if (!plan) {
    return null;
  }

  // Return in legacy format expected by tests
  return {
    key: plan.key,
    name: plan.name,
    creditsPerMonth: plan.creditsPerCycle,
    maxRollover: plan.maxRollover ?? plan.creditsPerCycle * plan.rolloverMultiplier,
    features: plan.features,
    recommended: plan.recommended,
    description: plan.description,
    price: plan.priceInCents / 100,
    interval: plan.interval,
  };
}

// =============================================================================
// Backward Compatibility Exports
// =============================================================================

/**
 * Export the subscription price map for backward compatibility
 * This maps price IDs to plan details
 */
export const SUBSCRIPTION_PRICE_MAP = buildSubscriptionPriceMap();

/**
 * Export subscription price IDs array for backward compatibility
 */
export const SUBSCRIPTION_PRICE_IDS = Object.values(STRIPE_PRICES).filter(priceId => {
  // Only include subscription plan price IDs, not credit pack price IDs
  const resolved = resolvePriceId(priceId);
  return resolved && resolved.type === 'plan';
});

/**
 * Get plan by key for backward compatibility
 * Re-export from subscription utils
 */
export function getPlanByKey(key: string): ILegacySubscriptionPlan | null {
  const config = getSubscriptionConfig();
  const plan = config.plans.find(p => p.key === key);
  if (!plan) return null;

  // Convert to legacy format
  return {
    key: plan.key,
    name: plan.name,
    creditsPerMonth: plan.creditsPerCycle,
    maxRollover: plan.maxRollover ?? plan.creditsPerCycle * plan.rolloverMultiplier,
    features: plan.features,
    recommended: plan.recommended,
  };
}

/**
 * Get display name for a subscription plan tier
 * Accepts either a string tier name or an object with priceId and subscriptionTier
 */
export function getPlanDisplayName(
  input:
    | string
    | {
        subscriptionTier?: string | null;
        priceId?: string | null;
        planKey?: string | null;
      }
): string {
  // Handle string input (legacy support)
  if (typeof input === 'string') {
    switch (input.toLowerCase()) {
      case 'starter':
      case 'STARTER_MONTHLY':
        return SUBSCRIPTION_PLANS.STARTER_MONTHLY.name;
      case 'hobby':
      case 'HOBBY_MONTHLY':
        return SUBSCRIPTION_PLANS.HOBBY_MONTHLY.name;
      case 'pro':
      case 'professional':
      case 'PRO_MONTHLY':
        return SUBSCRIPTION_PLANS.PRO_MONTHLY.name;
      case 'business':
      case 'BUSINESS_MONTHLY':
        return SUBSCRIPTION_PLANS.BUSINESS_MONTHLY.name;
      default:
        return input;
    }
  }

  // Handle object input with multiple possible fields
  const { subscriptionTier, priceId, planKey } = input;

  // First try subscriptionTier - normalize to proper display name
  if (subscriptionTier) {
    switch (subscriptionTier.toLowerCase()) {
      case 'starter':
        return SUBSCRIPTION_PLANS.STARTER_MONTHLY.name;
      case 'hobby':
        return SUBSCRIPTION_PLANS.HOBBY_MONTHLY.name;
      case 'pro':
      case 'professional':
        return SUBSCRIPTION_PLANS.PRO_MONTHLY.name;
      case 'business':
        return SUBSCRIPTION_PLANS.BUSINESS_MONTHLY.name;
      default:
        // Capitalize first letter as fallback
        return subscriptionTier.charAt(0).toUpperCase() + subscriptionTier.slice(1);
    }
  }

  // Then try priceId lookup
  if (priceId) {
    const plan = getPlanForPriceId(priceId);
    if (plan) {
      return plan.name;
    }
  }

  // Then try planKey lookup
  if (planKey) {
    const plan = getPlanByKey(planKey);
    if (plan) {
      return plan.name;
    }
  }

  // Final fallback
  return 'Unknown Plan';
}

// =============================================================================
// Unified Resolver Exports
// =============================================================================

/**
 * Export unified resolver functions for easy import by other modules
 * These provide the single source of truth for price lookups
 */
export {
  getPriceIndex,
  resolvePriceId,
  resolvePlanOrPack,
  assertKnownPriceId,
  getPlanByPriceId,
  buildSubscriptionPriceMap,
  buildStripePrices,
  buildSubscriptionPlans,
  buildCreditPacks,
  buildHomepageTiers,
};

/**
 * Check if Stripe is properly configured for payments
 * This is a convenience function that returns true if the essential configuration is present
 */
export function isStripeConfigured(): boolean {
  const validation = validateStripeConfig();
  return validation.isValid && serverEnv.STRIPE_SECRET_KEY.length > 0;
}
